use std::collections::{BTreeSet, HashMap};
use std::fs::{DirEntry, File};
use std::io::{Read, Write};
use std::mem::size_of;
use common::redr;
use crate::file_info::FileInfo;
use crate::sha256::{Sha256, sha256_from_path};
use sha3::Digest;
use serde::{Deserialize, Serialize};


use crate::error::MsetError;

type Description = String;

pub struct MalwareSet {
    mal_set: BTreeSet<Sha256>,
    sha_to_description: HashMap<Sha256, Description>,
}

impl MalwareSet {
    fn new_empty() -> Self {
        Self {
            mal_set: Default::default(),
            sha_to_description: Default::default()
        }
    }

    fn append_signature(&mut self, sha: Sha256, desc: Description) {
        self.mal_set.insert(sha);
        self.sha_to_description.insert(sha, desc);
    }

    pub fn eval_file(&self, file: &mut redr::FileReader) -> Result<FileInfo, MsetError> {
        let sha256 = crate::sha256::sha256_from_file_pointer(file)?;
        let sha_str = hex::encode_upper(&sha256);

        let file_info = self.match_(&sha256)?;
        println!("\"{sha_str}\" -> {:?}", &file_info);

        Ok(file_info)
    }

    pub fn match_(&self, sha: &Sha256) -> Result<FileInfo, MsetError> {
        if self.mal_set.contains(sha) {
          return Ok(FileInfo::Malicious(self.sha_to_description[sha].clone()))
        }

        Ok(FileInfo::Clean)
    }

    pub fn from_dir(path_to_dir: &str) -> Result<MalwareSet, MsetError> {
        let paths = std::fs::read_dir(path_to_dir)?;

        let mut malset = MalwareSet::new_empty();
        for path in paths {
            let path = path?;
            //log::trace!("path: {:?}", &path);
            if path.file_type()?.is_file() {
                let sha =
                    sha256_from_path(path.path().into_os_string().into_string().unwrap().as_str())?;
                malset.append_signature(sha, Self::create_file_info(&path, &sha)?);
                log::trace!("path: {:?}", &path);
            }
        }

        log::info!("mset size: {}", malset.mal_set.len());
        Ok(malset)
    }

    fn create_file_info(path: &DirEntry, sha256: &Sha256) -> Result<String, MsetError> {
        Ok(format!("name: {}\nsha256: {}\ndescription: {:?}\n", path.file_name().into_string()?, hex::encode_upper(&sha256), path.metadata()?))
    }

    pub fn unpack_to_dir(&self, out_dir: String) {
        let path = std::path::Path::new(&out_dir);
        for (sha, desc) in self.sha_to_description.iter() {
            let file_path = path.join(hex::encode_upper(&sha));
            std::fs::write(file_path, desc).unwrap();
        }
    }
}


#[derive(Debug, Serialize, Deserialize)]
struct MsetHeader {
    magic: u32,
    checksum: Sha256,
    elem_count: u32,
}

impl MsetHeader {
    const MSET_MAGIC_U32: u32 = 0x5445354D; //M5ET
    const MSET_MAGIC: [u8; 4] = [0x4D, 0x35, 0x45, 0x54]; //M5ET

    fn verify_magic(&self) -> Result<(), MsetError> {
        if self.magic != Self::MSET_MAGIC_U32 {
            return Err(MsetError::IncorrectMagicError { current: self.magic.to_string() });
        }
        Ok(())
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct SignatureHeader {
    sha: Sha256,
    size: u32,
    offset: u32,
}

#[derive(Debug, Serialize, Deserialize)]
struct Signature {
    header: SignatureHeader,
    data: Vec<u8>,
}

pub(crate) type DatabaseId = u64;
#[derive(Debug)]
pub(crate) struct MsetDeserializer {
    mset_header: MsetHeader,
    data: Vec<u8>,
}

impl MsetDeserializer {
    const MAX_BUF_LEN: u64 = 0x400000; // 4 MB
    const MSIG_HEADER_SIZE: usize = size_of::<MsetHeader>();

    pub(crate) fn new(name: &str) -> Result<Self, MsetError> {
        let mut file = std::fs::File::open(name)?;
        let metadata = file.metadata()?;

        if metadata.len() > Self::MAX_BUF_LEN {
            return Err(MsetError::IncorrectFileSizeError { size: metadata.len() });
        }

        let mut buffer = vec![0; metadata.len() as usize];
        let _ = file.read(&mut buffer)?;

        Self::new_with_buffer(buffer)
    }

    pub(super) fn new_with_buffer(
        mut data: Vec<u8>,
    ) -> Result<Self, MsetError> {
        if data.len() < Self::MSIG_HEADER_SIZE {
            return Err(MsetError::IncorrectFileSizeError { size: data.len() as u64 });
        }
        let mset_header: MsetHeader = bincode::serde::decode_from_slice(
            &data[..Self::MSIG_HEADER_SIZE],
            bincode::config::legacy(),
        )?
            .0;
        mset_header.verify_magic()?;
        data.drain(..Self::MSIG_HEADER_SIZE);

        let mut reader = Self { mset_header, data };
        reader.verify_checksum()?;

        Ok(reader)
    }


    fn verify_checksum(&self) -> Result<(), MsetError> {
        let mut hasher = sha3::Sha3_256::new();
        hasher.update(&self.mset_header.elem_count.to_le_bytes());
        hasher.update(&self.data);
        let mut checksum_buf = Sha256::default();
        checksum_buf.copy_from_slice(&hasher.finalize()[..]);
        if self.mset_header.checksum != checksum_buf {
            return Err(MsetError::MsetChecksumError {
                current: hex::encode(checksum_buf),
                expected: hex::encode(self.mset_header.checksum),
            });
        }
        Ok(())
    }

    pub fn get_malset(&self) -> Result<MalwareSet, MsetError> {
        let elem_count = self.mset_header.elem_count as usize;
        let signature_header_size = size_of::<SignatureHeader>();
        let start_of_data = elem_count * signature_header_size;

        let mut malset = MalwareSet::new_empty();
        for i in 0..elem_count {
            let curr_header_offset = i * signature_header_size;
            let sig_header: SignatureHeader = bincode::serde::decode_from_slice(
                &self.data[curr_header_offset..],
                bincode::config::legacy(),
            )?
                .0;

            if sig_header.size > Self::MAX_BUF_LEN as u32 {
                return Err(MsetError::IncorrectSignatureSizeError { size: sig_header.size });
            }

            let start_offset = sig_header.offset as usize + start_of_data;
            let end_offset = start_offset + sig_header.size as usize;
            if end_offset > self.data.len() {
                return Err(MsetError::IncorrectSignatureSizeError { size: sig_header.size });
            }

            let signature_data = self.data[start_offset..end_offset].to_vec();
            let description = String::from_utf8_lossy(&signature_data);
            malset.append_signature(sig_header.sha, description.into());
        }

        Ok(malset)
    }
}

pub struct MsetSerializer {
    sig_headers_vec: Vec<SignatureHeader>,
    curr_offset: u32,
    descriptions: Vec<u8>,
}

impl MsetSerializer {
    pub(crate) fn new_empty() -> Self {
        Self { sig_headers_vec: Vec::new(), curr_offset: 0, descriptions: Vec::new() }
    }

    pub fn new(malset: &MalwareSet) -> Self {
        let mut ser = Self::new_empty();
        for (sha, desc) in malset.sha_to_description.iter() {
            ser.serialize_signature(sha.clone(), desc.clone().into_bytes());
        }
        ser
    }

    pub(crate) fn serialize_signature(&mut self, sha: Sha256, mut data: Vec<u8>) {
        self.sig_headers_vec.push(SignatureHeader {
            sha,
            size: data.len() as u32,
            offset: self.curr_offset,
        });

        self.descriptions.append(&mut data);
        self.curr_offset = self.descriptions.len() as u32;
    }

    pub fn serialize(&self, mset_name: &str) -> Result<(), MsetError> {
        let mut file = std::fs::File::create(mset_name)?;

        let mut checksum_buf = Sha256::default();
        checksum_buf.copy_from_slice(&self.calculate_checksum()?);

        let mset_header = MsetHeader {
            magic: MsetHeader::MSET_MAGIC_U32,
            checksum: checksum_buf,
            elem_count: self.sig_headers_vec.len() as u32,
        };

        let header = bincode::serde::encode_to_vec(&mset_header, bincode::config::legacy())?;
        file.write_all(&header)?;

        //write info about each sig
        for header in &self.sig_headers_vec {
            let db = bincode::serde::encode_to_vec(&header, bincode::config::legacy())?;
            file.write_all(&db)?;
        }

        //write descriptions to file
        file.write_all(&self.descriptions)?;
        Ok(())
    }

    fn calculate_checksum(&self) -> Result<Sha256, MsetError> {
        let mut hasher = sha3::Sha3_256::new();

        hasher.update(&(self.sig_headers_vec.len() as u32).to_le_bytes());

        for header in &self.sig_headers_vec {
            hasher.update(&bincode::serde::encode_to_vec(&header, bincode::config::legacy())?);
        }

        hasher.update(&self.descriptions);
        Ok(hasher.finalize().into())
    }
}
